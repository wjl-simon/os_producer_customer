/******************************************************************
 * The Main program with the two functions. A simple
 * example of creating and using a thread is provided.
 ******************************************************************/

#include "helper.h"
#include <cstdio>
#include <cstdlib>

//using namespace std;

void *producer (void *id);
void *consumer (void *id);

// The job queue
queue<Job*> jobQueue;
// Currently newest job id
int newestJobId = 0;
// The mutex for all producers and consumers
pthread_mutex_t mutex;

#define PRO_SEM 0
#define CON_SEM 1

int main (int argc, char **argv)
{
  // Maximum queue size, num of jobs generated by a producer, num of producers, num of consumers
  int maxQueueSize, proJobNum, proNum, conNum;
  
  //--- Geting the parameters from the command line
  int temp;
  for(int i = 1; i < argc; i++)
  {
    temp = check_arg(argv[i]);
    switch(i)
    {
      case 1:
        if(temp == -1)
        {
          fprintf(stderr,"Invalid argument for the maximum job queue size\n");
          exit(-1);
        }
        else
          maxQueueSize = temp;
        break;
      case 2:
        if(temp == -1)
        {
          fprintf(stderr,"Invalid argument for the number of jobs generated by a producer\n");
          exit(-1);
        }
        else
          proJobNum = temp;
        break;
      case 3:
        if(temp == -1)
        {
          fprintf(stderr,"Invalid argument for the number of producers\n");
          exit(-1);
        }
        else
          proNum = temp;
        break;
      case 4:
        if(temp == -1)
        {
          fprintf(stderr,"Invalid argument for the number of consumers\n");
          exit(-1);
        }
        else
          conNum = temp;
        break;
      default: exit(-1);
    }
  }

  
  //---Semaphores creation and initialisation: sem 0 - producer sem; 1 - consumer sem
  const int SEM_SET_ID = sem_create(SEM_KEY,2);  // sem set id
  if(SEM_SET_ID == -1)
  {
    fprintf(stderr,"ERROR: cannot create semaphores\n"); exit(-1);
  }

  sem_init(SEM_SET_ID,PRO_SEM,maxQueueSize); // initialising producer semaphore
  sem_init(SEM_SET_ID,CON_SEM,0); // initialising consumer semephore

  
  //--- Mutex initialisation
  pthread_mutex_init(&mutex,nullptr);

  
  //--- Generating threads
  pthread_attr_t attr; // seting threads to be joinable
  pthread_attr_init(&attr), pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_JOINABLE);
  pthread_t producers[proNum], consumers[conNum]; // producer/consumer thread array

  int errcode;
  ProConArg argPro[proNum]; ProConArg argCon[conNum]; // parameters for the producers/consumers
  
  for(int i = 0; i < proNum; i++) // producer
  {
    argPro[i] = {i+1,SEM_SET_ID,proJobNum,maxQueueSize};
    errcode = pthread_create(&producers[i],&attr,producer,(void*) &argPro[i]);
    if(errcode)
    {
      fprintf(stderr,"ERROR: cannot generate Producer(%d) thread\n",i+1);
      exit(-1);
    }
  }

  for(int i = 0; i < conNum; i++) // consumer
  {
    argCon[i] = {i+1,SEM_SET_ID,0,0};
    errcode = pthread_create(&consumers[i],nullptr,consumer,(void*) &argCon[i]);
    if(errcode)
    {
      fprintf(stderr,"ERROR: cannot generate Consumer(%d) thread\n",i+1);
      exit(-1);
    }
  }

  
  //--- The main thread should pthread_join() the pro/con threads
  for(int i = 0; i < proNum; i++)
    pthread_join(producers[i],nullptr);
  
  for(int i = 0; i < conNum; i++)
    pthread_join(consumers[i],nullptr);


  //--- Clean-up: destorying the mutex and semaphores, etc
  pthread_attr_destroy(&attr);
  pthread_mutex_destroy(&mutex);
  sem_close(SEM_SET_ID);
  
 
  return 0;
}



void *producer (void *parameter) 
{
  ProConArg* proArg = (ProConArg*) parameter;
  int producerID = proArg->id;
  int const SEM_SET_ID = proArg->SETID;
  int proJobNum = proArg->proJobNum;
  int maxQueueSize = proArg->maxQueueSize;

  Job* jobptr;
  int newJobDura; // duration of a new job
  
  for(int i = 0; i < proJobNum; i++)
  {
    //=== Decrement the producer semephore
    // This thread may be blocked due to a full queue, or even gets killed if waits for 20+s
    if(sem_wait(SEM_SET_ID,PRO_SEM))
    {
      fprintf(stderr,"Producer(%d): No more jobs to generate\n", producerID);
      pthread_exit(0);
    }
    
    //=== Lock the mutex
    pthread_mutex_lock(&mutex);

    //=== Procude a new job 
    newestJobId = newestJobId%maxQueueSize + 1; // update the newest job id
    newJobDura = rand()%10 + 1; // random job duration, 1-10s
    jobptr = new Job(newestJobId,newJobDura);
      
    //=== Deposit the job to the queue
    jobQueue.push(jobptr);
    fprintf(stderr,"Producer(%d): Job id %d duration %d\n",
            producerID, newestJobId, newJobDura);

    //=== Unlock the mutex
    pthread_mutex_unlock(&mutex);

    //=== Increment the consumer sem
    sem_signal(SEM_SET_ID,CON_SEM);

    //=== Sleep for (randomly) 1-5 sec before generting the next job
    if(i < proJobNum)
    {
      sleep(rand()%5 + 1);
    }
  }

  //=== No more jobs to generate
  fprintf(stderr,"Producer(%d): No more jobs to generate\n", producerID);
  
  pthread_exit(0);
}


void *consumer (void *parameter) 
{
  ProConArg* conArg = (ProConArg*) parameter;
  int consumerID = conArg->id;
  int const SEM_SET_ID = conArg->SETID;

  int jobToDoId, jobToDoDura;
  
  while(1)  // always tries to consume untill gets blocked for 20+s and then gets killed
  {
    //=== Decrement the consumer sem
    if(sem_wait(SEM_SET_ID,CON_SEM))
    {
      fprintf(stderr,"Consumer(%d): No more job left\n", consumerID);
      pthread_exit(0);
    }

    //=== Lock the mutex
    pthread_mutex_lock(&mutex);

    //fprintf(stderr,"Consumer(%d): Locked!\n", consumerID);

    //=== Withdraw a job from the queue
    jobToDoId = jobQueue.front()->jobID, jobToDoDura = jobQueue.front()->duration;
    delete jobQueue.front();
    jobQueue.pop();

    //=== Unlock the mutex
    pthread_mutex_unlock(&mutex);
    
    //=== Increment the producer sem
    sem_signal(SEM_SET_ID,PRO_SEM);
  
    //=== Execute the job
    fprintf(stderr,"Consumer(%d): Job id %d executing sleep duration %d\n",
            consumerID, jobToDoId, jobToDoDura);
    sleep(jobToDoDura);
  
    //=== Job finished
    fprintf(stderr,"Consumer(%d): Job id %d completed\n",consumerID,jobToDoId);
  }
  
  pthread_exit(0);
}
